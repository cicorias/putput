import logging
from functools import reduce
from pathlib import Path
from typing import Any
from typing import Callable
from typing import Dict  # pylint: disable=unused-import
from typing import Iterable
from typing import Mapping
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TypeVar
from typing import Union
from typing import overload

import yaml

from putput.combiner import combine
from putput.expander import expand
from putput.expander import expand_utterance_patterns_ranges_and_groups
from putput.expander import get_base_item_map
from putput.joiner import ComboOptions
from putput.logger import get_logger
from putput.presets.factory import get_preset
from putput.validator import validate_pattern_def

try:
    get_ipython() # type: ignore
    from tqdm import tqdm_notebook as tqdm # pragma: no cover
except NameError:
    from tqdm import tqdm

_E_H_MAP = Mapping[Any, Sequence[Callable[[Sequence[Sequence[str]], Sequence[str], Sequence[Tuple[str, int]]],
                                          Tuple[Sequence[Sequence[str]], Sequence[str], Sequence[Tuple[str, int]]]]]]
_C_H_MAP = Mapping[Any, Sequence[Callable[[Any, Any, Any], Tuple[Any, Any, Any]]]]
_T_UP_KEY = TypeVar('_T_UP_KEY',
                    _C_H_MAP,
                    _E_H_MAP,
                    Mapping[Any, ComboOptions])
T_PIPELINE = TypeVar('T_PIPELINE', bound='Pipeline')

class Pipeline:
    """Transforms a pattern definition into labeled data for a variety of NLP tasks."""

    # pylint: disable=too-many-instance-attributes
    def __init__(self,
                 pattern_def_path: Path,
                 *,
                 dynamic_token_patterns_map: Optional[Mapping[str, Sequence[Sequence[Sequence[str]]]]] = None,
                 token_handler_map: Optional[Mapping[str, Callable[[str, str], str]]] = None,
                 group_handler_map: Optional[Mapping[str, Callable[[str, Sequence[str]], str]]] = None,
                 expansion_hooks_map: Optional[_E_H_MAP] = None,
                 combo_hooks_map: Optional[_C_H_MAP] = None,
                 combo_options_map: Optional[Mapping[Any, ComboOptions]] = None,
                 final_hook: Optional[Callable[[Any, Any, Any], Any]] = None,
                 LOG_LEVEL: int = logging.WARNING
                 ) -> None:
        """Instantiates Pipeline.

        Validates the pattern definition, expands utterance patterns used as keys in maps,
        and sets public attributes.

        Args:
            dynamic_token_patterns_map: The 'dynamic' counterpart to the 'static' section in the
                pattern definition. This mapping between token and token patterns is useful in
                scenarios where tokens and token patterns cannot be known before runtime.
            token_handler_map: A mapping between a token and a function with args
                (token, phrase generated by token) that returns a handled token. If 'DEFAULT'
                is specified as the token, the handler will apply to all tokens not otherwise
                specified in the mapping.
            group_handler_map: A mapping between a group name and a function with args
                (group name, handled tokens) that returns a handled group. If 'DEFAULT' is
                specified as the group name, the handler will apply to all groups not otherwise
                specified in the mapping.
            expansion_hooks_map: A mapping between an utterance pattern and hooks to apply after
                the expansion phase. If 'DEFAULT' is specified as the utterance pattern, the hooks
                will apply to all utterance patterns not otherwise specified in the mapping.
            combo_hooks_map: A mapping between an utterance pattern and hooks to apply after
                the combination phase. If 'DEFAULT' is specified as the utterance pattern, the hooks
                will apply to all utterance patterns not otherwise specified in the mapping.
            final_hook: A function with args (utterance, handled tokens, handled groups) that returns
                a value that will be returned by the flow method. If combo_hooks_map is specified,
                the input args to final_hook will be the return values of the last hook in combo_hooks_map.
        """
        self.pattern_def = _load_pattern_def(pattern_def_path)
        validate_pattern_def(self.pattern_def)
        maps_with_utterance_pattern_as_key = (i for i in (expansion_hooks_map, combo_hooks_map, combo_options_map) if i)
        self._validate_key_types_for_maps_with_utterance_pattern_as_key(maps_with_utterance_pattern_as_key)

        self.dynamic_token_patterns_map = dynamic_token_patterns_map
        self.token_handler_map = token_handler_map
        self.group_handler_map = group_handler_map

        groups_map = get_base_item_map(self.pattern_def, 'groups')
        if expansion_hooks_map:
            self.expansion_hooks_map = self._expand_map_with_utterance_pattern_as_key(
                expansion_hooks_map, groups_map) # type: Optional[_E_H_MAP]
        else:
            self.expansion_hooks_map = None

        if combo_hooks_map:
            self.combo_hooks_map = self._expand_map_with_utterance_pattern_as_key(
                combo_hooks_map, groups_map)  # type: Optional[_C_H_MAP]
        else:
            self.combo_hooks_map = None

        if combo_options_map:
            self.combo_options_map = self._expand_map_with_utterance_pattern_as_key(
                combo_options_map, groups_map) # type: Optional[Mapping[Any, ComboOptions]]
        else:
            self.combo_options_map = None

        self.final_hook = final_hook
        self._logger = get_logger(__name__, LOG_LEVEL)

    @classmethod
    def from_preset(cls: Type[T_PIPELINE],
                    preset: Union[str, Callable],
                    pattern_def_path: Path,
                    **kwargs: Any) -> T_PIPELINE:
        if isinstance(preset, str):
            preset = get_preset(preset)
        init_kwargs = preset()
        init_kwargs.update(kwargs)
        return cls(pattern_def_path, **init_kwargs)

    @property
    def logger(self) -> logging.Logger:
        return self._logger

    def flow(self, *, disable_progress_bar: bool = False) -> Iterable:
        for utterance_combo, tokens, groups in self._expand(disable_progress_bar=disable_progress_bar):
            for utterance, handled_tokens, handled_groups in self._combine(utterance_combo,
                                                                           tokens,
                                                                           groups,
                                                                           disable_progress_bar=disable_progress_bar):
                if self.final_hook:
                    yield self.final_hook(utterance, handled_tokens, handled_groups)
                else:
                    yield utterance, handled_tokens, handled_groups

    def _combine(self,
                 utterance_combo: Sequence[Sequence[str]],
                 tokens: Sequence[str],
                 groups: Sequence[Tuple[str, int]],
                 *,
                 disable_progress_bar: bool = False
                 ) -> Iterable[Tuple[str, Sequence[str], Sequence[str]]]:
        combo_options = self._get_combo_options(tokens, self.combo_options_map) if self.combo_options_map else None

        sample_size, combo_gen = combine(utterance_combo,
                                         tokens,
                                         token_handler_map=self.token_handler_map,
                                         combo_options=combo_options)
        with tqdm(combo_gen,
                  desc='Combination...',
                  total=sample_size,
                  disable=disable_progress_bar,
                  leave=False,
                  miniters=1) as pbar:
            for utterance, handled_tokens in pbar:
                handled_groups = self._compute_handled_groups(groups, handled_tokens)
                if self.combo_hooks_map:
                    utterance, handled_tokens, handled_groups = self._execute_joining_hooks(tokens,
                                                                                            (utterance,
                                                                                             handled_tokens,
                                                                                             handled_groups),
                                                                                            self.combo_hooks_map)
                yield utterance, handled_tokens, handled_groups

    def _expand(self,
                *,
                disable_progress_bar: bool = False
                ) -> Iterable[Tuple[Sequence[Sequence[str]], Sequence[str], Sequence[Tuple[str, int]]]]:
        ilen, exp_gen = expand(self.pattern_def, dynamic_token_patterns_map=self.dynamic_token_patterns_map)
        with tqdm(exp_gen, desc='Expansion...', total=ilen, disable=disable_progress_bar, miniters=1) as expansion_tqdm:
            for utterance_combo, tokens, groups in expansion_tqdm:
                log_msg = '{}'.format(', '.join(tokens))
                self._logger.info(log_msg)
                if self.expansion_hooks_map:
                    utterance_combo, tokens, groups = self._execute_joining_hooks(tokens,
                                                                                  (utterance_combo, tokens, groups),
                                                                                  self.expansion_hooks_map)
                yield utterance_combo, tokens, groups

    def _get_combo_options(self,
                           tokens: Sequence[str],
                           combo_options_map: Mapping[Any, ComboOptions]
                           ) -> Optional[ComboOptions]:
        # pylint: disable=no-self-use
        options_map = {} # type: Dict[Union[str, Tuple[str, ...]], ComboOptions]
        options_map.update(combo_options_map)
        key = tuple(tokens)
        return options_map.get(key) or options_map.get('DEFAULT')

    @overload
    def _execute_joining_hooks(self,
                               tokens: Sequence[str],
                               args: Tuple[Sequence[Sequence[str]], Sequence[str], Sequence[Tuple[str, int]]],
                               hooks_map: _E_H_MAP,
                               ) -> Tuple[Sequence[Sequence[str]], Sequence[str], Sequence[Tuple[str, int]]]:
        # pylint: disable=no-self-use
        # pylint: disable=unused-argument
        pass # pragma: no cover

    @overload
    def _execute_joining_hooks(self,
                               tokens: Sequence[str],
                               args: Tuple[Any, Any, Any],
                               hooks_map: _C_H_MAP,
                               ) -> Tuple[Any, Any, Any]:
        # pylint: disable=no-self-use
        # pylint: disable=unused-argument
        pass # pragma: no cover

    def _execute_joining_hooks(self,
                               tokens: Sequence[str],
                               args: Union[Tuple[Sequence[Sequence[str]], Sequence[str], Sequence[Tuple[str, int]]],
                                           Tuple[Any, Any, Any]],
                               hooks_map: Union[_E_H_MAP, _C_H_MAP]
                               ) -> Union[Tuple[Sequence[Sequence[str]], Sequence[str], Sequence[Tuple[str, int]]],
                                          Tuple[Any, Any, Any]]:
        # pylint: disable=no-self-use
        key = tuple(tokens) if tuple(tokens) in hooks_map else 'DEFAULT'
        if key in hooks_map:
            args = reduce(lambda args, hook: hook(*args), hooks_map[key], args)
        return args

    def _compute_handled_groups(self,
                                groups: Sequence[Tuple[str, int]],
                                handled_tokens: Sequence[str],
                                ) -> Sequence[str]:
        start_index = 0
        handled_groups = []
        for group in groups:
            group_name, end_index = group
            group_handler = self._get_group_handler(group_name)
            handled_group = group_handler(group_name, handled_tokens[start_index: start_index + end_index])
            handled_groups.append(handled_group)
            start_index += end_index
        return tuple(handled_groups)

    def _get_group_handler(self, group_name: str) -> Callable[[str, Sequence[str]], str]:
        default_group_handler = lambda group_name, handled_tokens: '{{{}({})}}'.format(group_name,
                                                                                       ' '.join(handled_tokens))
        if self.group_handler_map:
            return (self.group_handler_map.get(group_name) or
                    self.group_handler_map.get('DEFAULT') or
                    default_group_handler)
        return default_group_handler

    def _expand_map_with_utterance_pattern_as_key(self,
                                                  map_with_utterance_pattern_as_key: _T_UP_KEY,
                                                  groups_map: Mapping[str, Sequence[str]]
                                                  ) -> _T_UP_KEY:
        # pylint: disable=no-self-use
        expanded_map = {}
        for key, hooks in map_with_utterance_pattern_as_key.items():
            if isinstance(key, str):
                expanded_map[key] = hooks
            else:
                expanded_utterance_patterns, _ = expand_utterance_patterns_ranges_and_groups((key,), groups_map)
                for expanded_utterance_pattern in expanded_utterance_patterns:
                    expanded_map[tuple(expanded_utterance_pattern)] = hooks # type: ignore
        return expanded_map

    def _validate_key_types_for_maps_with_utterance_pattern_as_key(self,
                                                                   maps: Iterable[Mapping]
                                                                   ) -> None:
        # Manually validating mappings as mypy does not support Mapping[Union[str, Tuple[str, ...]], Any]
        # https://github.com/python/mypy/issues/2300
        # Additionally TypedDict is not a good solution because we want to support arbitrary keys
        # pylint: disable=no-self-use, too-many-nested-blocks
        for map_with_utterance_patterns_as_key in maps:
            if map_with_utterance_patterns_as_key:
                for key in map_with_utterance_patterns_as_key.keys():
                    if isinstance(key, tuple):
                        for item in key:
                            if not isinstance(item, str):
                                raise ValueError("Each item in key: {}. Must be of type str.".format(key))
                    elif not isinstance(key, str):
                        raise ValueError("Invalid key: {}. Must be of type str or Tuple[str, ...].".format(key))

def _load_pattern_def(pattern_def_path: Path) -> Mapping:
    with pattern_def_path.open(encoding='utf-8') as pattern_def_file:
        pattern_def = yaml.load(pattern_def_file, Loader=yaml.BaseLoader)
    return pattern_def
